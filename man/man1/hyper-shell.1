.\" Man page generated from reStructuredText.
.
.TH "HYPER-SHELL" "1" "Jun 25, 2020" "1.8.0" "hyper-shell"
.SH NAME
hyper-shell \- process shell commands in parallel
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH SYNOPSIS
.nf
hyper\-shell client  [\-h] [\fIargs\fP\&...]
hyper\-shell server  [\-h] \fITASKFILE\fP [\fIargs\fP\&...]
hyper\-shell cluster [\-h] \fITASKFILE\fP [\fIargs\fP\&...]
.fi
.sp
.SH DESCRIPTION
.sp
The \fBhyper\-shell\fP utility is a cross\-platform, high performance computing
utility for processing arbitrary shell commands over a distributed, asynchronous
queue.
.sp
The hyper\-shell server program accepts command lines as input and publishes
them to a shared queue. Any number of hyper\-shell clients can connect to that
server either locally or from a remote machine. The clients pull these tasks off
the queue asynchronously. The hyper\-shell cluster program allows the user to
automatically launch an appropriate number of clients under various schemes.
.sp
The hyper\-shell cluster can also be launched in \fIparsl\fP mode. This loads a
named configuration from \fB~/.hyper\-shell/parsl_config.py\fP and dispatches
tasks using the given scheduler (e.g., SLURM, Kubernetes). See
\fI\%parsl\-project.org\fP
.SH GLOBAL OPTIONS
.SS Network Options
.sp
When running locally and in \fBcluster\fP mode, nothing need be specified.
Otherwise, the \fBserver\fP\(aqs bind address may need to be set to allow for
remote connections. The port number and authkey are arbitrary choices.
.INDENT 0.0
.TP
.B \-H, \-\-host \fIADDR\fP
Address for server (default: localhost). For the \fBserver\fP this is
the bind address to use. For clients to be allowed to connect you will
need to set this to 0.0.0.0 for the server.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
user@host\-1 ~$ hyper\-shell server \-H 0.0.0.0
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
user@host\-2 ~$ hyper\-shell client \-H host\-1
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B \-p, \-\-port \fIPORT\fP
Port number for server (default: 50001). The port number is an arbitrary
choice and just needs to be allowed by the server (not blocked or reserved).
.TP
.B \-k, \-\-authkey \fIKEY\fP
Cryptographic key for connection (default: \(aq\-\-BADKEY\-\-\(aq). This is set by the
server and required for clients to connect. The default is intentionally
meant to suggest you set something more appropriate. In \fBcluster\fP mode, a
128bit hex\-token is autogenerated if none is explicitly provided.
.UNINDENT
.SS Logging Options
.sp
All logging messages are written to \fBstderr\fP to allow for command outputs
to occupy \fBstdout\fP\&. By default, the logging level is set to \fIWARNING\fP, so
no logging will be done unless there is some kind of issue (e.g., non\-zero
exit status). Logging messages are colored according to their severity; blue,
green, yellow, red, and purple for debug, info, warning, error, and critical,
respectively. If \fBstderr\fP is being redirected, colors will be disabled.
.sp
The \fB\-\-logging\fP switch is meant to facilitate job tracking in a distributed
computing context, including timestamps and hostnames in messages.
.INDENT 0.0
.TP
.B \-v\fP,\fB  \-\-verbose
Include information level messages. (conflicts with \fB\-\-debug\fP).
.TP
.B \-d\fP,\fB  \-\-debug
Include debugging level messages. (conflicts with \fB\-\-verbose\fP).
.TP
.B \-l\fP,\fB  \-\-logging
Show detailed syslog style messages. This disables colorized output and
alters the format of messages to include a timestamp, hostname, and the
level name.
.UNINDENT
.SH SERVER USAGE
.sp
The hyper\-shell server reads command lines from a file (or \fBstdin\fP). If no
arguments are given, a usage statement is printed. To avoid this and simply run
with all defaults, reading from \fBstdin\fP, \fB\-\fP symbolizes standard input.
.sp
Any command that returns a non\-zero exit status will have a warning message
emitted and the original command line will be printed to \fBstdout\fP\&. In this
way, the server acts like a sieve, consuming commands and emitting failures.
.SS Server Options
.INDENT 0.0
.TP
.B \-o, \-\-output \fIFILE\fP
Path to file for failed commands (default: <stdout>).
.TP
.B \-s, \-\-maxsize \fISIZE\fP
Maximum size of the queue (default: 10000). To avoid the server queueing up
too many tasks, this will force the server to block if clients have not yet
taken enough commands. This is helpful for pipelines.
.UNINDENT
.SH CLIENT USAGE
.sp
The client connects to the server and pulls commands off one at a time,
executing them on the local shell. The shell and environment inherit from the
client\(aqs execution environment.
.sp
The output of commands are simply redirected to \fBstdout\fP unless otherwise
specified by \fB\-\-output\fP\&. To isolate output from individual commands, you can
specify how to redirect from inside the command template; e.g.,
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ hyper\-shell client ... \-t \(aq{} >$TASK_ID.out\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
With no arguments, the client will just print a usage statement and exit.
To prompt the client to run with all default arguments, a \fB\-\-\fP is
interpreted as a simple noarg.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ hyper\-shell client \-\-
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Client Options
.INDENT 0.0
.TP
.B \-x, \-\-timeout \fISEC\fP
Length of time in seconds before disconnecting (default: 0). If finished
with previous command and no other commands are published by the server
after this period of time, automatically disconnect and shutdown. A
timeout of 0 is special and means never timeout.
.TP
.B \-t, \-\-template \fICMD\fP
Template command (default: "{}"). Any valid command can be a template.
All "{}" are substituted (if present) as the input task argument.
.TP
.B \-o, \-\-output \fIFILE\fP
Path to file for command outputs (default: <stdout>).
.UNINDENT
.SS Parsl Mode
.sp
These options are pass to the client by the cluster program to trigger a single
client to launch \fIparsl\fP\&. Running more than one client instance in parsl
mode will invoke more than one parsl cluster.
.INDENT 0.0
.TP
.B \-\-parsl [\-\-profile \fINAME\fP]
Hand\-off tasks to Parsl (default profile: "local"). The "local" profile just
uses threads and really only works as a placeholder for testing purposes.
Running the cluster in \fB\-\-local\fP mode is to be preferred.
.UNINDENT
.SH CLUSTER USAGE
.sp
The program offers a concise means to launch a workflow. In all cases, a
server is started. Depending on the launch scheme selected, one or more
clients will be launched locally or remotely for you.
.SS Cluster Modes
.sp
Each mode is mutually exclusive. The associated partner options are only
valid if given with their launcher option.
.INDENT 0.0
.TP
.B \-\-local [\-N | \-\-num\-cores \fINUM\fP]
Launch clients locally. A new client process will be started for each "core"
requested. By default, it will launch as many clients as there are cores on
the machine. These clients will launch using the exact path to the current
executable.
.TP
.B \-\-ssh [\-\-nodefile \fIFILE\fP]
Launch clients with SSH. The \fInodefile\fP should enumerate the hosts to be
used. An SSH session will be created for every line in this file.
SSH\-keys should be setup to allow password\-less connections. If not given,
a global ~/.hyper\-shell/nodefile can be used.
.TP
.B \-\-mpi [\-\-nodefile \fIFILE\fP]
Launch clients with MPI. The \fIFILE\fP is passed to the \fB\-machinefile\fP option
for \fBmpiexec\fP\&. If not given, rely on \fBmpiexec\fP to know what to do.
.TP
.B \-\-parsl [\-\-profile \fINAME\fP]
Launch a single client to run in \fIparsl\fP mode. This loads a
\fBparsl.config.Config\fP object from \fB~/.hyper\-shell/parsl_config.py\fP\&. If
not specified, the profile defaults to "local", which just uses some number
of threads locally.
.UNINDENT
.SS Cluster Options
.sp
Some of these options are merely passed through to the server or the client.
.INDENT 0.0
.TP
.B \-f, \-\-failed \fIFILE\fP
A file path to write commands which exited with a non\-zero status. If not
specified, nothing will be written.
.TP
.B \-o, \-\-output \fIFILE\fP
A file path to write the output of commands. By default, if this option is
not specified, all command outputs will be redirected to \fBstdout\fP .
.TP
.B \-s, \-\-maxsize \fISIZE\fP
Maximum size of the queue (default: 10000). To avoid the server queueing up
too many tasks, this will force the server to block if clients have not yet
taken enough commands. This is helpful for pipelines.
.TP
.B \-t, \-\-template \fICMD\fP
Template command (default: "{}").
.UNINDENT
.SH ENVIRONMENT VARIABLES
.sp
All environment variables that start with the \fBHYPERSHELL_\fP prefix will be
injected into the execution environment of the tasks with the prefix stripped.
.sp
Example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ export HYPERSHELL_PATH=/other/bin:$PATH
$ export HYPERSHELL_OTHER=FOO
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
All tasks will then have \fBPATH=/other/bin:$PATH\fP defined for the task as well
as a new variable, \fBOTHER\fP\&.
.sp
\fBHYPERSHELL_EXE\fP
.INDENT 0.0
.INDENT 3.5
When running the hyper\-shell cluster with \fB\-\-ssh\fP (or similar) it is
not uncommon for the hyper\-shell on the remote system to either be in a
different location or not necessarily available on the \fIPATH\fP\&. Using the
\fBHYPERSHELL_EXE\fP environment variable, set an explicit path to use.
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ export HYPERSHELL_EXE=/other/bin/hyper\-shell
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBHYPERSHELL_CWD\fP
.INDENT 0.0
.INDENT 3.5
When executed directly, the hyper\-shell client will run tasks in the same
directory as the client is running in. This can be changed by specifying the
\fBHYPERSHELL_CWD\fP\&.
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ export HYPERSHELL_CWD=$HOME/other
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBHYPERSHELL_LOGGING_LEVEL\fP
.INDENT 0.0
.INDENT 3.5
You can specify what logging level to use without the need for a command line
switch by defining this variable. Both numbered and named values are allowed;
e.g., 0\-4 or one of DEBUG, INFO, WARNING, ERROR, and CRITICAL.
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ export HYPERSHELL_LOGGING_LEVEL=DEBUG
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBHYPERSHELL_LOGGING_HANDLER\fP
.INDENT 0.0
.INDENT 3.5
You can specify what logging style to use without the need for a command line
switch by defining this variable. Allowed values are STANDARD or DETAILED,
corresponding to the basic colorized messages and the syslog style detailed
messages, respectively.
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ export HYPERSHELL_LOGGING_HANDLER=DETAILED
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
All tasks will also have special variables defined within their environment
that are specific to that instance.
.sp
\fBTASK_ID\fP
.INDENT 0.0
.INDENT 3.5
The unique integer identifier for this task. The value of \fBTASK_ID\fP is
a count starting from zero set by the server.
.UNINDENT
.UNINDENT
.sp
\fBTASK_ARG\fP
.INDENT 0.0
.INDENT 3.5
The input argument for this command. This  the  variable equivalent of \(aq{}\(aq
and can be substituted as such. This may be useful for shell\-isms in
the command template.
.UNINDENT
.UNINDENT
.SH EXAMPLES
.SS Simple Cluster
.sp
Process an existing list of commands from some \fBtaskfile\fP\&. Presumably, one
could execute \fBtaskfile\fP directly and the lines would be executed in serial.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ hyper\-shell cluster taskfile \-f taskfile.failed
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Dynamic Pipeline
.sp
Await tasks and dispatch them as they arrive. It is common practice to use
all\-caps to mark files as being transient in nature. In this case, \fBTASKFILE\fP
is like a queue unto itself. Enable verbose logging with \fB\-vl\fP, redirect
outputs and view logging messages but also append them to a file using \fBtee\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ tail \-f TASKFILE | hyper\-shell cluster \-vl \-N4 \-f FAILED \e
    2>&1 1>OUTPUTS | tee \-a hyper\-shell.log
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Server and Clients
.sp
Start a server manually to publish tasks. Define an access key using \fB\-k\fP
and set the bind address for the server so clients can connect remotely.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ hyper\-shell server \-dlk \(aqsome\-key\(aq \-H 0.0.0.0 < taskfile > taskfile.failed
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
On different machines launch one or more clients. This can be done manually,
or in an automated fashion.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ hyper\-shell client \-dlk \(aqsome\-key\(aq \-H \(aqserver\-hostname\(aq > local.out
.ft P
.fi
.UNINDENT
.UNINDENT
.SS HPC Job (Direct)
.sp
Schedule tasks on a computing cluster using a job scheduler, such as
\fI\%SLURM\fP\&. A basic job script might be:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#!/bin/bash
#SBATCH \-\-nodes=2
#SBATCH \-\-tasks\-per\-node=12
#SBATCH \-\-account=ACCOUNT

# launch server
hyper\-shell server \-dlH 0.0.0.0 < TASKFILE > FAILED \e
    2>>hyper\-shell.log

# launch clients
srun hyper\-shell client \-dlH \(gahostname\(ga > OUTPUTS \e
    2>>hyper\-shell.log
.ft P
.fi
.UNINDENT
.UNINDENT
.SS HPC Job (Elastic)
.sp
Instead of scheduling a job with a fixed size, allow for a continuous pipeline
to exist and elastically scale the required backend\-nodes according to the task
load.
.sp
On a login\-node on the cluster:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ hyper\-shell cluster \-dl \-\-parsl \-\-profile=myconfig < TASKFILE \e
    >OUTPUTS 2>>hyper\-shell.log
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This will create a server and a single client which launches \fIparsl\fP using the
named configuration. In \fB~/.hyper\-shell/parsl_config.py\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# see parsl.readthedocs.io
from parsl.config import Config

myconfig = Config(
    # implement your custom configuration
)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Elastic Cloud Computing
.sp
On a small persistent compute instance, run the server in a pipeline
configuration. Then, setup your \fIparsl\fP configuration to use \fIKubernetes\fP
(or similar) to elastically scale compute as necessary. Be sure to include
both \fIhyper\-shell\fP and \fIparsl\fP in your compute image.
.SS Hybrid Makefile and Hyper\-Shell
.sp
Using a \fIMakefile\fP to define a directed acyclic graph (DAG) for your
computations, whether in a local or HPC context is robust and to be encouraged.
In fact, \fIGNU Make\fP offers a parallel execution mode (using the \fB\-j\fP flag). On
a single compute node this will not only execute tasks in parallel but uses the
filesystem to track successful and failed commands, facilitating the re\-execution
of incomplete tasks without needlessly executing tasks that have succeeded.
.sp
In the context of tasks such as these, the dependency graph has branches that do
not connect for independent tasks. Example, issuing \fBmake outputs/task\-1.out\fP
may be completely isolated from \fBmake outputs/task\-2.out\fP\&. Let \fIMake\fP retain
the DAG and execution formulae; if one defines a top\-level target that simply
prints all the final targets of the tasks, you can pipe that into something like
\fIhyper\-shell\fP to run in a distributed context when necessary.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ make list | hyper\-shell cluster \-t \(aqmake {}\(aq \-\-mpi \-\-nodefile $NODEFILE
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You might even embed that in the \fIMakefile\fP itself to run in a distributed mode.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cluster:
    $(make) list | hyper\-shell cluster \-t \(aq$(make) {}\(aq \-\-mpi \-\-nodefile $(NODEFILE)
.ft P
.fi
.UNINDENT
.UNINDENT
.SH SEE ALSO
.sp
ssh(1), mpiexec(1), tail(1), tee(1), make(1)
.SH AUTHOR
Geoffrey Lentner <glentner@purdue.edu>.
.SH COPYRIGHT
2019 Geoffrey Lentner
.\" Generated by docutils manpage writer.
.
